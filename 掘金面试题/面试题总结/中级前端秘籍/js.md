# 1. 讲讲 Map 和 Set？

1. Map 的 key 相比较普通对象来说更为灵活，普通对象的 key 只能以基础数据类型作为 key 值，并且所有传入的 key 值都会被转化成 string 类型，而 Map 的 key 可以是各种数据类型格式。
2. Set 可以讲讲它去重的特性。

# 2. WeakMap 和 Map 之间的区别？

WeakMap 只能以复杂数据类型作为 key，并且 key 值是弱引用，对于垃圾回收更加友好。

# 3. 讲讲原型链？

[JavaScript 深入之从原型到原型链](https://github.com/mqyqingfeng/Blog/issues/2)

函数的 prototype 属性

- 每个函数都有一个 prototype 属性，这个属性指向了一个对象，这个对象就是调用该构造函数实例化的对象的原型。

那什么是原型？

- 每个对象(null 除外)在创建的时候就会关联一个另外一个对象，这个对象就是我们所说的原型，每一个对象都会从原型上继承属性。

对象的 **proto** 属性

- 每个对象(null 除外)都具有一个属性 **proto**，这个属性会指向该对象的原型。

既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？

- 每个原型都有一个 constructor 属性指向关联的构造函数。

原型链

- 当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。

# 4. 讲讲 this

[JavaScript 中的 this](https://juejin.im/post/6844903488304971789)

> 1. this 指向调用者这个关系一定要清楚
> 2. 要知道改变 this 指向的几种方式(call, bind, apply)
> 3. 箭头函数中 this 的特殊性要能讲清楚

如果函数作为构造函数用，那么其中的 this 就代表它即将 new 出来的对象。为啥呢？new 做了啥呢？

- new 做了下面这些事:
  - 创建一个临时对象
  - 给临时对象绑定原型
  - 给临时对象对应属性赋值
  - 将临时对象 return

那么箭头函数的 this 是怎么确定的呢？

- 箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值，也就是说箭头函数的 this 在词法层面就完成了绑定。apply，call 方法只是传入参数，却改不了 this。

# 5. 浅拷贝和深拷贝的区别

- 浅拷贝：一般指的是把对象的第一层拷贝到一个新对象上去，
- 深拷贝：一般需要借助递归实现，如果对象的值还是个对象，要进一步的深入拷贝，完全替换掉每一个复杂类型的引用。

# 6. 讲讲事件冒泡和事件捕获以及事件代理？

[你真的理解 事件冒泡 和 事件捕获 吗？](https://juejin.im/post/6844903834075021326)

1. 事件冒泡和事件捕获

```js
<div id="outer">
  <p id="inner">Click me!</p>
</div>
// 上面的代码当中一个div元素当中有一个p子元素，如果两个元素都有一个click的处理函数，那么我们怎么才能知道哪一个函数会首先被触发呢？
```

为了解决页面中事件流（事件发生顺序）的问题微软和网景提出了两种几乎完全相反的概念。

事件冒泡:

- 事件会从最内层的元素开始发生，一直向上传播，直到 document 对象。
- p -> div -> body -> html -> document

事件捕获:

- 事件会从最外层开始发生，直到最具体的元素。
- document -> html -> body -> div -> p

2. addEventListener 的第三个参数

- true - 事件句柄在捕获阶段执行（即在事件捕获阶段调用处理函数）
- false- false- 默认。事件句柄在冒泡阶段执行（即表示在事件冒泡的阶段调用事件处理函数）

3. 事件代理

常规做法:

- 我们想要在点击每个 li 标签时，输出 li 的数据 。常规做法是遍历每个 li ,然后在每个 li 上绑定一个点击事件：
- 这种做法在 li 较少的时候可以使用，但如果有一万个 li ，那就会导致性能降低（少了遍历所有 li 节点的操作，性能上肯定更加优化）。

事件代理:

- 由于事件冒泡机制，点击了 li 后会冒泡到 ul ，此时就会触发绑定在 ul 上的点击事件，再利用 target 找到事件实际发生的元素，就可以达到预期的效果。
- 我们为 ul 绑定一个事件，然后通过 e.target 找到实际发生的元素，这样就可以达到预期的效果。
- 使用事件代理的好处不仅在于将多个事件处理函数减为一个，而且对于不同的元素可以有不同的处理方法。假如上述列表元素当中添加了其他的元素节点（如：a、span 等），我们不必再一次循环给每一个元素绑定事件，直接修改事件代理的事件处理函数即可。

冒泡还是捕获？

- 对于事件代理来说，在事件捕获或者事件冒泡阶段处理并没有明显的优劣之分，但是由于事件冒泡的事件流模型被所有主流的浏览器兼容，从兼容性角度来说还是建议大家使用事件冒泡模型。

IE 浏览器兼容

- IE 浏览器对 addEventListener 兼容性并不算太好，只有 IE9 以上可以使用。

```js
// 要兼容旧版本的IE浏览器，可以使用IE的attachEvent函数
object.attachEvent(event, function)
// 两个参数与addEventListener相似，分别是事件和处理函数，默认是事件冒泡阶段调用处理函数，要注意的是，写事件名时候要加上"on"前缀（"onload"、"onclick"等）。
```

阻止事件冒泡:

- 给子级加 event.stopPropagation( )
- 在事件处理函数中返回 false
- event.target==event.currentTarget，让触发事件的元素等于绑定事件的元素，也可以阻止事件冒泡；

但是这两种方式是有区别的。return false 不仅阻止了事件往上冒泡，而且阻止了事件本身(默认事件)。event.stopPropagation()则只阻止事件往上冒泡，不阻止事件本身。

阻止默认事件:

- event.preventDefault( )
- return false
